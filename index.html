<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galapagos: Escort Mission</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            touch-action: none;
            font-family: 'Noto Sans KR', sans-serif;
            user-select: none;
        }

        /* --- UI ë ˆì´ì•„ì›ƒ --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            border-bottom: 2px solid #8B4513;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
        }

        .stat-value {
            font-family: 'Black Han Sans', sans-serif;
            font-size: 24px;
            color: #FFD700;
            text-shadow: 2px 2px 0 #000;
        }

        /* HP ê²Œì´ì§€ ìŠ¤íƒ€ì¼ */
        .hp-bar-bg {
            width: 120px;
            height: 15px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #fff;
            margin-top: 5px;
        }

        .hp-bar-fill {
            height: 100%;
            background: #ff3d00;
            width: 100%;
            transition: width 0.2s;
        }

        /* ì§„í–‰ë„ ë°” */
        .progress-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
        }

        .progress-indicator {
            position: absolute;
            top: -15px;
            left: 0%;
            font-size: 24px;
            transform: translateX(-50%);
            transition: left 0.1s linear;
        }

        /* íŒì—… (ì‹œì‘, ì¢…ë£Œ, í´ë¦¬ì–´) */
        .popup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            color: white;
            text-align: center;
        }

        .popup h1 {
            font-family: 'Black Han Sans', sans-serif;
            font-size: 40px;
            margin: 0 0 20px 0;
            color: #4CAF50;
            text-shadow: 3px 3px 0 #000;
        }

        .popup p {
            font-size: 18px;
            color: #ccc;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .btn {
            background: #FF5722;
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 0 #BF360C;
            transition: transform 0.1s;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="header">
            <div class="stat-box">
                <span>STAGE</span>
                <span class="stat-value" id="ui-stage">1</span>
            </div>
            <!-- HP í‘œì‹œ -->
            <div class="stat-box">
                <span>SHIP HP</span>
                <div class="hp-bar-bg">
                    <div class="hp-bar-fill" id="ui-hp-bar"></div>
                </div>
                <span style="font-size:12px; margin-top:2px;" id="ui-hp-text">10/10</span>
            </div>
        </div>

        <!-- í•˜ë‹¨ ì§„í–‰ë„ -->
        <div class="progress-bar-container">
            <div class="progress-indicator" id="ui-progress-icon">â›µ</div>
        </div>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="start-screen" class="popup">
        <h1>ì‹ëŸ‰ ìˆ˜ì†¡ ì‘ì „</h1>
        <p>ë°°ê°€ ëª©ì ì§€ê¹Œì§€ ì•ˆì „í•˜ê²Œ ë„ì°©í•˜ë„ë¡<br>ë§¹ìˆ˜ë“¤ì„ ë§‰ì•„ë‚´ì„¸ìš”!</p>
        <button class="btn" onclick="startGame(0)">GAME START</button>
    </div>

    <!-- ê²°ê³¼ í™”ë©´ (Game Over / Clear) -->
    <div id="result-screen" class="popup hidden">
        <h1 id="result-title">MISSION COMPLETE!</h1>
        <p id="result-desc">ë°°ê°€ ì•ˆì „í•˜ê²Œ ë„ì°©í–ˆìŠµë‹ˆë‹¤.</p>
        <button id="result-btn" class="btn">NEXT STAGE</button>
    </div>

    <script>
        // --- ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'hit') { // í½ ì†Œë¦¬
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'damage') { // ì‚ë¹… ê²½ê³ ìŒ
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(200, now + 0.3);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'clear') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523, now);
                osc.frequency.setValueAtTime(784, now + 0.2);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            }
        }

        // --- ê²Œì„ ì„¤ì • ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 40;

        // ë§µ í¬ê¸° (ë„“ê²Œ ì„¤ì •í•˜ì—¬ ì´ë™ ì‹œê°„ í™•ë³´)
        const MAP_COLS = 30;
        const MAP_ROWS = 30;

        const ASSETS = {
            player: 'ğŸ‘¸', // ì—¬ì„± ì „ì‚¬
            enemy: 'ğŸ†',  // í‘œë²”
            ship: 'â›µ',   // ë°°
            wheel: 'ğŸ›’',  // ë°”í€´ ì¥ì‹
            tree: 'ğŸŒµ',
            rock: 'ğŸª¨'
        };

        const STAGES = [
            { level: 1, enemies: 5, spawnRate: 100, hp: 5 },
            { level: 2, enemies: 10, spawnRate: 80, hp: 5 },
            { level: 3, enemies: 15, spawnRate: 60, hp: 4 } // ë” ì–´ë ¤ì›€
        ];

        // ê²Œì„ ìƒíƒœ
        let currentStageIdx = 0;
        let config;
        let gameState = 'stop';
        let frameCount = 0;

        // ì—”í‹°í‹°
        let player;
        let ship;
        let enemies = [];
        let particles = [];
        let decorations = [];

        // ì¹´ë©”ë¼
        let camera = { x: 0, y: 0 };
        let viewW, viewH;

        // ì…ë ¥
        const input = { x: 0, y: 0, active: false };

        // --- í´ë˜ìŠ¤ ---

        class Ship {
            constructor(maxHp) {
                this.radius = 35;
                // ì‹œì‘: ì¢Œì¸¡ í•˜ë‹¨
                this.x = TILE_SIZE * 2;
                this.y = (MAP_ROWS - 2) * TILE_SIZE;

                // ëª©í‘œ: ìš°ì¸¡ ìƒë‹¨
                this.targetX = (MAP_COLS - 2) * TILE_SIZE;
                this.targetY = TILE_SIZE * 2;

                this.maxHp = maxHp;
                this.hp = maxHp;

                // ì†ë„: ì´ˆë‹¹ 1ì…€ (60í”„ë ˆì„ ê¸°ì¤€, 1ì´ˆì— TILE_SIZEë§Œí¼ ì´ë™)
                this.speed = TILE_SIZE / 60;

                // ì´ë™ ê°ë„ ê³„ì‚°
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                this.angle = Math.atan2(dy, dx);

                this.totalDist = Math.hypot(dx, dy);
                this.invincible = 0;
            }

            update() {
                // ëª©í‘œì§€ì  ë„ë‹¬ ì²´í¬
                const dist = Math.hypot(this.targetX - this.x, this.targetY - this.y);
                if (dist < 10) {
                    stageClear();
                    return;
                }

                // ì´ë™
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // ë¬´ì  ì‹œê°„ ê°ì†Œ
                if (this.invincible > 0) this.invincible--;

                // ì§„í–‰ë¥  UI ì—…ë°ì´íŠ¸
                const currentDist = Math.hypot(this.x - (TILE_SIZE * 2), this.y - ((MAP_ROWS - 2) * TILE_SIZE));
                const progress = Math.min(100, (currentDist / this.totalDist) * 100);
                document.getElementById('ui-progress-icon').style.left = `${progress}%`;
            }

            draw(ctx) {
                // ê·¸ë¦¼ì
                drawShadow(ctx, this.x, this.y, this.radius, ASSETS.ship, 1.5);

                // ë°° ë³¸ì²´
                if (this.invincible > 0 && Math.floor(Date.now() / 100) % 2 === 0) return; // ê¹œë¹¡ì„

                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);

                // ë°”í€´ (ì¥ì‹)
                ctx.font = '20px Arial';
                ctx.fillText(ASSETS.wheel, -15, 15);
                ctx.fillText(ASSETS.wheel, 15, 15);

                // ë°°
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // ëª©ì ì§€ ë°©í–¥ ë³´ê²Œ ë°˜ì „ (ìš°ì¸¡ ìƒë‹¨ì´ë¯€ë¡œ ê¸°ë³¸ì´ ë§ìŒ)
                ctx.fillText(ASSETS.ship, 0, -10);

                ctx.restore();
            }

            takeDamage() {
                if (this.invincible > 0) return;
                this.hp--;
                this.invincible = 60; // 1ì´ˆ ë¬´ì 
                playSound('damage');
                updateUI();

                // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼
                const ui = document.getElementById('ui-layer');
                ui.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
                setTimeout(() => ui.style.transform = 'none', 100);

                if (this.hp <= 0) gameOver();
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 15;
                this.speed = 250; // ë°°ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„
                this.angle = 0;
            }

            update(dt) {
                if (input.active) {
                    const worldX = input.x + camera.x;
                    const worldY = input.y + camera.y;
                    const dx = worldX - this.x;
                    const dy = worldY - this.y;

                    if (Math.hypot(dx, dy) > 5) {
                        this.angle = Math.atan2(dy, dx);
                        this.x += Math.cos(this.angle) * this.speed * dt;
                        this.y += Math.sin(this.angle) * this.speed * dt;
                    }
                }

                // ë§µ ë°– ì œí•œ
                this.x = Math.max(0, Math.min(this.x, MAP_COLS * TILE_SIZE));
                this.y = Math.max(0, Math.min(this.y, MAP_ROWS * TILE_SIZE));
            }

            draw(ctx) {
                drawShadow(ctx, this.x, this.y, this.radius, ASSETS.player);
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);
                if (Math.cos(this.angle) < 0) ctx.scale(-1, 1);

                // ìºë¦­í„°
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ASSETS.player, 0, 0);
                // ëŒ€ì¥ í‘œì‹œ
                ctx.font = '12px Arial';
                ctx.fillText('ğŸª“', 0, -20);
                ctx.restore();
            }
        }

        class Enemy {
            constructor() {
                // ë°° ì£¼ë³€ í™”ë©´ ë°–ì—ì„œ ìŠ¤í°
                const angle = Math.random() * Math.PI * 2;
                const dist = 400 + Math.random() * 200;
                this.x = ship.x + Math.cos(angle) * dist;
                this.y = ship.y + Math.sin(angle) * dist;

                // ë§µ ì•ˆìª½ìœ¼ë¡œ ë³´ì •
                this.x = Math.max(0, Math.min(this.x, MAP_COLS * TILE_SIZE));
                this.y = Math.max(0, Math.min(this.y, MAP_ROWS * TILE_SIZE));

                this.radius = 18;
                this.speed = 80 + Math.random() * 40; // ë°°ë³´ë‹¤ ë¹ ë¦„
                this.stunned = 0;
            }

            update(dt) {
                if (this.stunned > 0) {
                    this.stunned -= dt;
                    return;
                }

                // ë¬´ì¡°ê±´ ë°°ë¥¼ í–¥í•´ ëŒì§„
                const dx = ship.x - this.x;
                const dy = ship.y - this.y;
                const angle = Math.atan2(dy, dx);

                this.x += Math.cos(angle) * this.speed * dt;
                this.y += Math.sin(angle) * this.speed * dt;
            }

            draw(ctx) {
                if (this.x - camera.x < -50 || this.x - camera.x > viewW + 50) return;

                drawShadow(ctx, this.x, this.y, this.radius, ASSETS.enemy);
                ctx.save();
                ctx.translate(this.x - camera.x, this.y - camera.y);

                if (this.stunned > 0) {
                    ctx.rotate(Math.random() * 0.5); // ê¸°ì ˆ íš¨ê³¼
                }

                ctx.font = '35px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(ASSETS.enemy, 0, 0);

                if (this.stunned > 0) ctx.fillText('ğŸ’«', 0, -20);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, char) {
                this.x = x; this.y = y;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = (Math.random() - 0.5) * 100;
                this.life = 1.0;
                this.char = char;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= 2.0 * dt;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.font = '20px Arial';
                ctx.fillText(this.char, this.x - camera.x, this.y - camera.y);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ë©”ì¸ í•¨ìˆ˜ ---

        function startGame(idx) {
            currentStageIdx = idx;
            config = STAGES[idx];

            // ì´ˆê¸°í™”
            ship = new Ship(config.hp);
            // í”Œë ˆì´ì–´ëŠ” ë°° ê·¼ì²˜ì—ì„œ ì‹œì‘
            player = new Player(ship.x + 50, ship.y);

            enemies = [];
            particles = [];

            // ì¥ì‹ ìƒì„±
            decorations = [];
            for (let i = 0; i < 100; i++) {
                decorations.push({
                    x: Math.random() * MAP_COLS * TILE_SIZE,
                    y: Math.random() * MAP_ROWS * TILE_SIZE,
                    char: Math.random() > 0.3 ? ASSETS.rock : ASSETS.tree,
                    scale: 0.5 + Math.random() * 0.5
                });
            }

            gameState = 'playing';
            updateUI();

            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('result-screen').classList.add('hidden');

            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('ui-stage').innerText = config.level;

            // HP Bar
            const hpPct = (ship.hp / ship.maxHp) * 100;
            const bar = document.getElementById('ui-hp-bar');
            bar.style.width = `${hpPct}%`;

            if (hpPct <= 30) bar.style.backgroundColor = 'red';
            else bar.style.backgroundColor = '#ff3d00'; // Orange-Red

            document.getElementById('ui-hp-text').innerText = `${ship.hp} / ${ship.maxHp}`;
        }

        function spawnEnemy() {
            if (enemies.length < config.enemies && Math.random() < 0.02) {
                enemies.push(new Enemy());
            }
        }

        function drawShadow(ctx, x, y, r, char, scale = 1) {
            ctx.save();
            ctx.translate(x - camera.x, y - camera.y);
            ctx.scale(1, 0.5);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(0, r, r * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState !== 'playing') return;
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            // 1. ì—…ë°ì´íŠ¸
            ship.update();
            player.update(dt);
            spawnEnemy();

            // ì¹´ë©”ë¼ê°€ ë°°ì™€ í”Œë ˆì´ì–´ ì¤‘ê°„ì„ ë¹„ì¶”ë„ë¡
            const camTargetX = (ship.x + player.x) / 2 - viewW / 2;
            const camTargetY = (ship.y + player.y) / 2 - viewH / 2;
            camera.x += (camTargetX - camera.x) * 0.1;
            camera.y += (camTargetY - camera.y) * 0.1;

            // ì¶©ëŒ ì²´í¬
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.update(dt);

                // í”Œë ˆì´ì–´ vs ì  (ëª¸í†µ ë°•ì¹˜ê¸°)
                const distPlayer = Math.hypot(e.x - player.x, e.y - player.y);
                if (distPlayer < player.radius + e.radius) {
                    // ì ì„ ë©€ë¦¬ íŠ•ê²¨ëƒ„
                    playSound('hit');
                    createParticles(e.x, e.y, 'ğŸ’¥');
                    const angle = Math.atan2(e.y - player.y, e.x - player.x);
                    e.x += Math.cos(angle) * 100; // ë„‰ë°±
                    e.y += Math.sin(angle) * 100;
                    e.stunned = 1.0; // 1ì´ˆ ê¸°ì ˆ
                }

                // ë°° vs ì  (ë°ë¯¸ì§€)
                const distShip = Math.hypot(e.x - ship.x, e.y - ship.y);
                if (distShip < ship.radius + e.radius) {
                    ship.takeDamage();
                    // ì  ì†Œë©¸ í›„ ì¬ìƒì„± (ë˜ëŠ” íŠ•ê²¨ë‚´ê¸°)
                    // ì—¬ê¸°ì„  ë°¸ëŸ°ìŠ¤ë¥¼ ìœ„í•´ ì ì„ ì œê±°í•˜ê³  ë‹¤ì‹œ ìŠ¤í°í•˜ê²Œ í•¨
                    createParticles(e.x, e.y, 'ğŸ’€');
                    enemies.splice(i, 1);
                }
            }

            particles.forEach((p, i) => {
                p.update(dt);
                if (p.life <= 0) particles.splice(i, 1);
            });

            // 2. ê·¸ë¦¬ê¸°
            ctx.fillStyle = '#E0D8B0'; // ì‚¬ë§‰ìƒ‰
            ctx.fillRect(0, 0, viewW, viewH);

            // ê·¸ë¦¬ë“œ (ë•… ëŠë‚Œ)
            ctx.strokeStyle = 'rgba(0,0,0,0.05)';
            ctx.lineWidth = 1;
            const offsetX = camera.x % TILE_SIZE;
            const offsetY = camera.y % TILE_SIZE;
            ctx.beginPath();
            for (let x = -offsetX; x < viewW; x += TILE_SIZE) { ctx.moveTo(x, 0); ctx.lineTo(x, viewH); }
            for (let y = -offsetY; y < viewH; y += TILE_SIZE) { ctx.moveTo(0, y); ctx.lineTo(viewW, y); }
            ctx.stroke();

            // ì˜¤ë¸Œì íŠ¸ ê·¸ë¦¬ê¸° (Y ì •ë ¬)
            // ì¥ì‹ì€ ë Œë”ë§ ìµœì í™”ë¥¼ ìœ„í•´ í™”ë©´ ë‚´ ê²ƒë§Œ
            const visibleDecor = decorations.filter(d =>
                d.x > camera.x - 50 && d.x < camera.x + viewW + 50 &&
                d.y > camera.y - 50 && d.y < camera.y + viewH + 50
            );

            // ì¥ì‹ì„ ì—”í‹°í‹°ì²˜ëŸ¼ ë³€í™˜í•´ì„œ ê·¸ë¦¬ê¸°
            visibleDecor.forEach(d => {
                drawShadow(ctx, d.x, d.y, 15, d.char, d.scale);
                ctx.font = `${30 * d.scale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(d.char, d.x - camera.x, d.y - camera.y);
            });

            const renderList = [ship, player, ...enemies];
            renderList.sort((a, b) => a.y - b.y);
            renderList.forEach(obj => obj.draw(ctx));

            particles.forEach(p => p.draw(ctx));

            requestAnimationFrame(gameLoop);
        }

        function createParticles(x, y, char) {
            for (let i = 0; i < 5; i++) particles.push(new Particle(x, y, char));
        }

        function stageClear() {
            gameState = 'clear';
            playSound('clear');
            document.getElementById('result-title').innerText = "ARRIVED!";
            document.getElementById('result-title').style.color = "#4CAF50";
            document.getElementById('result-desc').innerText = "ë°°ê°€ ë¬´ì‚¬íˆ ë„ì°©í–ˆìŠµë‹ˆë‹¤.";

            const btn = document.getElementById('result-btn');
            if (currentStageIdx < STAGES.length - 1) {
                btn.innerText = "NEXT STAGE";
                btn.onclick = () => startGame(currentStageIdx + 1);
            } else {
                btn.innerText = "ALL CLEAR";
                btn.onclick = () => startGame(0);
            }
            document.getElementById('result-screen').classList.remove('hidden');
        }

        function gameOver() {
            gameState = 'gameover';
            document.getElementById('result-title').innerText = "MISSION FAILED";
            document.getElementById('result-title').style.color = "#FF3d00";
            document.getElementById('result-desc').innerText = "ì‹ëŸ‰ ë°°ê°€ íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤.";

            const btn = document.getElementById('result-btn');
            btn.innerText = "RETRY";
            btn.onclick = () => startGame(currentStageIdx);

            document.getElementById('result-screen').classList.remove('hidden');
        }

        function resize() {
            viewW = window.innerWidth;
            viewH = window.innerHeight;
            canvas.width = viewW;
            canvas.height = viewH;
        }

        window.addEventListener('resize', resize);

        // ì…ë ¥ í•¸ë“¤ëŸ¬
        const handleInputStart = (x, y) => { input.active = true; input.x = x; input.y = y; };
        const handleInputMove = (x, y) => { if (input.active) { input.x = x; input.y = y; } };
        const handleInputEnd = () => { input.active = false; };

        window.addEventListener('mousedown', e => handleInputStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleInputMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', handleInputEnd);

        window.addEventListener('touchstart', e => {
            handleInputStart(e.touches[0].clientX, e.touches[0].clientY);
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }, { passive: false });
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            handleInputMove(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        window.addEventListener('touchend', handleInputEnd);

        resize();

    </script>
</body>

</html>